---
layout:     post   				    # 使用的布局（不需要改）
title:      屏幕渲染（一）			# 标题 
subtitle:   积少成多 #副标题
date:       2020-06-22				# 时间
author:     bkun 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - iOS
---



# 屏幕渲染

### GPU CPU

CPU：现代计算机整个系统的运算核心、控制核心。

CPU 拥有更多的缓存空间以及复杂的控制单元，计算能力并不是 CPU 的主要目的，更倾向于可以更快地访问数据，同时复杂的控制单元也能更快速地处理逻辑，串行计算。

GPU：可进行绘图运算工作的专用微处理器，是连接计算机和显示终端的纽带。

GPU 拥有更多的计算单元，具有更强的计算能力，有更多的控制单元，CPU 基于大吞吐量而设计，适合大规模的并行计算。

### 图像渲染

计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应过程称为**渲染**，**渲染**过程中最常见的技术就是**光栅化**。光栅化就是将数据转化为可见像素的过程。

GPU 则是执行转化过程中的硬件部分。

GPU 图像渲染可分为两个部分：
	1. 把 3D 坐标转换为 2D 坐标
	2. 把 2D 欧标转变为实际的有颜色的像素


图像渲染阶段：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggimqneftpj30xo07qaam.jpg)

除了 Application 阶段外都是由 GPU 处理。

##### Application ：得到图元
这个阶段具体处于 CPU 时期。在可能对图像进行一系列的操作或改变，最终将新的图片信息（图元，通常是三角形，线段，顶点）传给下一个阶段。

##### Geometry ：处理图元
 1. 顶点着色器。该阶段的输入是 顶点数据（Vertex Data） 数据，比如以数组的形式传递 3 个 3D 坐标用来表示一个三角形。顶点数据是一系列顶点的集合。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器可以对顶点属性进行一些基本处理。
 2. 形状（图元）装配：该阶段将顶点着色器输出的所有顶点作为输入，并将所有的点装配成指定图元的形状。
 3. 几何着色器：该阶段把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的图元来生成其他形状的。

##### Rasterization 图元转为像素
1. 光栅化：该阶段会把图元映射为最终屏幕上相应的像素，生成片段（片段 Fragement 是渲染一个像素所需要的所有数据）。即将图元信息转为一系列像素。

##### Pixel 处理像素，得到位图
1. 片段着色器：对片段进行裁切。裁切会丢弃超出视图意外的所有像素。
2. 测试与混合：这个阶段主要处理片段的前后位置以及透明度。这个阶段会检测各个着色片段的深度值 z 坐标，从而判断片段的前后位置，以及是否应该被舍弃。同时也会计算相应的透明度值，从而进行片段的混合，得到最终的颜色。


### 屏幕图像显示原理

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjrx343f6j30b408dgma.jpg)
如图所示，CRT 的电子枪从上到下逐行扫描，扫描完成后显示器就呈现一帧画面。然后电子枪回到初始位置进行下一次扫描。为了同步显示器的显示过程和系统的视频控制器，先四起会用硬件时钟产生一系列的定时信号。当电子枪换行进行扫描时，显示器会发出一个水平同步信号 HSync。当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号 VSync。显示器通常以固定频率进行刷新，这个个刷新就是 Vsync 信号产生的频率。对于 iOS 而言，app 应该尽量保证 60 FPS 才是最好的体验。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjs38vxuaj30dw0803ys.jpg)
CPU 计算好显示内容提交至 GPU，GPU 渲染完成后将渲染结果存入帧缓冲区，视频控制器会按照 VSync 信号逐帧读取帧缓冲区的数据。

### 屏幕撕裂

在这种单一缓存的模式下，最理想的情况就是一个流畅的流水线：每次电子束从头开始新的一帧的扫描时，CPU+GPU 对于该帧的渲染流程已经结束，渲染好的位图已经放入帧缓冲器中。但这种完美的情况是非常脆弱的，很容易产生屏幕撕裂

CPU+GPU 的渲染流程是一个非常耗时的过程。如果在电子束开始扫描新的一帧时，位图还没有渲染好，而是在扫描到屏幕中间时才渲染完成，被放入帧缓冲器中，此时已扫描的部分就是上一帧的画面，而未扫描的部分则会显示新的一帧图像，这就造成屏幕撕裂。

### 垂直同步 + 双缓冲机制

iOS 用了垂直同步 + 双缓冲机制。
垂直同步相当于给帧缓冲区加锁，当电子枪完成一帧的扫描，将要从头开始扫描时，就会发出一个垂直同步信号。只有当视频控制器接收到垂直同步信号，才会将帧缓冲区中的位图更新为下一帧，这样避免了屏幕撕裂。

双缓冲机制，会增加一个新的备用缓冲区（back buffer），渲染结果会预先保存在 back buffer 中，在接收到垂直同步信号时，视频控制器会将 back buffer 中的内容换到帧缓冲区（frame buffer）中（实际上是交换了内存地址）。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjsmnm0lrj32a00prtkn.jpg)

### 掉帧
启用了垂直同步和双缓冲机制后，能够解决屏幕撕裂，但会造成新的问题掉帧。
![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggjspnhromj31620c8wik.jpg)
由于垂直同步机制，如果在一个 Vsync 时间内，CPU + GPU 没有完成图像的渲染保存在缓冲区中，则这一帧将会被丢弃，等待下一次机会在显示，而这是显示屏会保留之前的内容不变，就这就界面卡顿的原因。


## 参考资料
[计算机那些事(8)——图形图像渲染原理](http://chuquan.me/2018/08/26/graphics-rending-principle-gpu/)

[iOS Rendering 渲染全解析（长文干货）](https://juejin.im/post/5ec35cc55188256d92438174)

[iOS 保持界面流畅的技巧](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)


# code

五年时光。
